# 垃圾回收算法

- 记录一下GC的学习过程

## 基本概念

- 对象
  - 程序中从堆区分配的内存都是对象
  - 对象分为头和域
    - 头里存储一些GC需要的信息
    - 申请出来的对象域里存储的都是各种类型的数据
    - 被GC回收的对象域里存储的可能不是原先的数据
  - 对象里一般有指针指向下一个正在使用的对象，称为对象间的引用关系
  - 活动对象和非活动对象
    - 活动对象:能通过程序里对象间的引用关系找到的对象都是活动对象，也就是说正在被使用的对象
    - 非活动对象:没有被引用的对象就是非活动对象，这也是GC收集的对象
- GC性能标志
  - 吞吐量
    - 每次GC运行时单位时间内能处理的内存总量
  - 堆使用效率
    - 对于堆空间内部的使用效率，比如头的大小，如果一个头越大，那么别的信息存储的就少了，效率就低了
    - 对于域内空间的使用，如果能使用的越少，那么效率就越低
  - 最大暂停时间
    - 每次GC运行时，主程序的暂停时间
  - 访问的局部性
    - 计算机有cache这个东西，访问cache的时候速度是很快的
    - 每次进入cache的内存都是连续的。
    - 所以GC算法可以通过尽量安排具有引用关系的对象在相邻的内存处，这样读取对象速度就很快

## 标记-清除算法

### 简单标记-清除

- 对活动对象的头部设立一个标记mark
- 核心算法:
  - 通过root这个根对象来找到程序内其他的活动对象，将它们的mark设置为true
  - 然后进行sweep，遍历整个堆区，如果mark是true，那么就标记为false，
  - 如果是false，就把对应的对象链入空闲链表。

- 总体概括下来:
  - 1.找到活动中的对象，然后给它们打上标记
  - 2.进行sweep，找到堆中没有标记的对象，把他们回收到freelist
  - 2.对于标记好的对象，去掉他们的标记，然后让程序继续运行
  - 这样程序中如果某些对象和其他对象没有了引用关系，第一步再去寻找的时候就无法标记他们
  - 从而这些对象就会被回收

- 分配:
  - 每次分配都会从freelist里寻找大于等于需求size的对象
  - 找到等于的直接分配
  - 找到大于的切割后分配
- 合并:
  - 为了防止产生内存碎片，GC会进行合并相邻内存块的操作
  - 在sweep的阶段，如果找到没有被标记的块，则会检查它和当前freelist里的第一个块也就是上一次发现的快是否连续，连续就进行合并，不连续就不合并
  - 书里的代码给出的只能合并地址高于当前freelist里第一个对象的内存，也就是说这不能前向合并，只能后向合并
- 优点:
  - 算法实现简单
  - 与保守GC算法兼容
    - 保守GC算法：对象是不能移动的

- 缺点

  - 容易产生内存碎片
    - 即使有合并算法，然而在极端的情况下还是会产生很多内存碎片(小的内存块)

  - 分配速度
    - 由于对象不连续，每次分配内存的时候都需要通过链表去遍历

  - 与写时复制技术不兼容
    - 写时复制技术是说当程序复制进程的时候，会进行一些拷贝，但肯定不会拷贝整个内存空间，所以他们之间会共享内存空间。
    - 当我们在向内存中写入的时候，不会直接向共享内存处写入，这样会乱套，进程会复制一块进程自己的私有内存，对这个私有内存进行写入，
    - 我们的GC算法每次都会对对象设置标志位，所以在那种需要写时复制的系统中，每次设置标志位都要复制一块私有内存，所以不需要的复制频繁发生，浪费了时间，所以这个算法和写时复制技术不兼容